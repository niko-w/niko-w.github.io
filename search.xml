<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Jmeter监控插件]]></title>
      <url>%2F2017%2F01%2F23%2FJmeter%E7%9B%91%E6%8E%A7%E6%8F%92%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[jmeter服务器监控插件 将JMeterPlugins-Extras.jar、JMeterPlugins-Standard.jar、CMDRunner.jar放入到jmeter所在的文件夹./lib/ext下(windows和linux上都需要) 在要监控的服务器上安装插件ServerAgent，解压ServerAgent-2.2.1.zip文件，进入文件下，运行./startAgent.sh（linux下） 以上操作后，在windows上打开jmeter，在监听器会看到许多以gp@gc开头的内容： 修改jmeter安装路径中：bin/jmeter.properties文件的以下行:（jmeterplugins 和thread有关系所以要修改配置文件） 1jmeter.save.saveservice.thread_counts=true 用法：在linux上运行监控插件生成PNG图片：12java -jar $CMDRunnerPath/CMDRunner.jar --tool Reporter --generate-png ThreadsStateOverTime.png--input-jtl 1.jtl --plugin-type ThreadsStateOverTime 生成LatenciesOverTime图片1java -jar /app/jmeter02/app/apache-jmeter-2.9/lib/ext/CMDRunner.jar --tool Reporter --input-jtl /app/jmeter02/app/apache-jmeter-2.9/bin/testresult0825.jtl --plugin-type LatenciesOverTime --generate-png report-latency.png 生成 TransactionsPerSecond 图片1java -jar /app/jmeter02/app/apache-jmeter-2.9/lib/ext/CMDRunner.jar --tool Reporter --input-jtl /app/jmeter02/app/apache-jmeter-2.9/bin/testresult0825.jtl --plugin-type TransactionsPerSecond --generate-png report-transactionPerSec.png 生成 添加监控 cpu、io、硬盘、memory图片（这个也可以各项分别设置（cpu、io、memory、硬盘））1java -jar /app/jmeter02/app/apache-jmeter-2.9/lib/ext/CMDRunner.jar --tool Reporter --input-jtl /app/jmeter02/app/apache-jmeter-2.9/bin/cpu.jtl --plugin-type PerfMon --generate-png report-cpu.png 生成csv图片：1java -jar $CMDRunnerPath/CMDRunner.jar --tool Reporter --generate-csv ThreadsStateOverTime.csv --input-jtl 1.jtl --plugin-type ThreadsStateOverTime 当然也可以一次性生成两个文件。下面是改命令的参数：1234–generate-png 指定png图片文件–generate-csv 指定csv文件名–input-jtl 指定要解析的jtl文件–plugin-type 指定要输出的数据类型，比如响应时间、cpu使用率、错误率等 Plugin Type Classes插件提供解析下面这些数据的对象： AggregateReport = JMeter’s native Aggregate Report, can be saved only as CSV 聚合报告 SynthesisReport = mix between JMeter’s native Summary Report and Aggregate Report, can be saved only as CSV ThreadsStateOverTime = Active Threads Over Time 线程数随时间的变化曲线 BytesThroughputOverTime 流量随时间的变化曲线 HitsPerSecond 点击率随时间的变化曲线 LatenciesOverTime 延迟随时间的变化曲线 PerfMon = PerfMon Metrics Collector 服务器参数随时间变化曲线注意这个需要在jmx脚本中添加，服务器监控，要指定ip、端口、监控项，还需要指定perfMon的输出文件，或者在命令行指定，如sh jmeter.sh -n -t HTTP请求-baidu.jmx -l 2.jtp -JforcePerfmonFile=true,这样会输出在当前路径。 ResponseCodesPerSecond 响应码随时间变化曲线 ResponseTimesDistribution 响应时间分布 ResponseTimesOverTime 响应时间随时间变化曲线 ResponseTimesPercentiles 响应时间的百分比 ThroughputVsThreads 吞吐率随线程变化曲线 TimesVsThreads = Response Times VS Threads 响应时间随线程变化曲线 TransactionsPerSecond 事务随时间变化曲线 PageDataExtractorOverTime 参考文章 JMeterPluginsCMD官网]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[tsung安装配置与使用]]></title>
      <url>%2F2017%2F01%2F09%2Ftsung%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[tsung介绍Tsung （以前称为IDX-Tsunami）是一个分布是负载测试工具。它与协议无关，目前可以用来测试HTTP, WebDAV, SOAP, PostgreSQL, MySQL, LDAP, and Jabber/XMPP Tsung 的主要特点是，他可以使用单CPU模拟大量用户，当用于集群中时，你使用它便能产生真正的负载，并且容易安装和维护。 Tsung 使用erlang开发，erlang –-tsung 力量的来源。 Erlang是一个并行化编程语言，tsung 是基于erlang 的OTP(Open Telecom Platform 并且从erang 继承了几个特征： 性能：erlang 支持在一个单一的虚拟机100万的轻量级进程。 可扩展性：自然分布，位置透明性。 容错：erlang强劲的容错系统。因此，错误从服务器发送到tsung不会影响整体。 tsung官方文档tsung和jmeter之间的对比jmeter与tsung分析对比 这篇自己没有细看，不过分析的挺详细CentOS压力测试工具Tsung安装、使用和图形报表生成Tsung用于压测MySQL服务器的脚本Tsung配置实例http详细说明Tsung系列教程-聂永]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[FastJson简单用法]]></title>
      <url>%2F2017%2F01%2F06%2FFastJson%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95%2F</url>
      <content type="text"><![CDATA[fastjson简介 Fastjson是一个Java语言编写的高性能功能完善的JSON库； fastjson采用独创的算法，将parse的速度提升到极致，超过所有json库，包括曾经号称最快的jackson。并且还超越了google的二进制协议protocol buf； Fastjson完全支持http://json.org的标准，也是官方网站收录的参考实现之一； 功能强大，支持各种JDK类型。包括基本类型、JavaBean、Collection、Map、Enum、泛型等。支持JDK5、JDK6、Android、阿里云手机等环境； 无依赖，不需要例外额外的jar，能够直接跑在JDK上； 开源，使用Apache License 2.0协议开源。https://github.com/alibaba/fastjson/wiki/%E9%A6%96%E9%A1%B5 fastjson生成json字符串(JavaBean,List&lt;JavaBean&gt;,List&lt;String&gt;,List&lt;Map&lt;String,Object&gt;)1String jsonStrng = JSON.toJSONString(object); fastjson 解析json字符串为四种类型 JavaBean 1Person person = JSON.parseObject(jsonString, Person.class); List&lt;JavaBean&gt; 1List&lt;Person&gt; listPerson = JSON.parseArray(jsonString,Person.class); List&lt;String&gt; 1List&lt;String&gt; listString = JSON.parseArray(jsonString,String.class); 4 List&lt;Map&lt;String,Object&gt;&gt;1List&lt;Map&lt;String, Object&gt;&gt; listMap = JSON.parseObject(jsonString, new TypeReference&lt;List&lt;Map&lt;String,Object&gt;&gt;&gt;()&#123;&#125;); fastjson使用实例如果你使用了maven，要使用fastjson,你只需在pom.xml文件中加入以下内容即可12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.1.42&lt;/version&gt;&lt;/dependency&gt; 使用介绍Fastjson的最主要的使用入口是com.alibaba.fastjson.JSON1import com.alibaba.fastjson.JSON; 相关的函数有：12345678public static final Object parse(String text); // 把JSON文本parse为JSONObject或者JSONArraypublic static final JSONObject parseObject(String text)； // 把JSON文本parse成JSONObjectpublic static final &lt;T&gt; T parseObject(String text, Class&lt;T&gt; clazz); // 把JSON文本parse为JavaBeanpublic static final JSONArray parseArray(String text); // 把JSON文本parse成JSONArraypublic static final &lt;T&gt; List&lt;T&gt; parseArray(String text, Class&lt;T&gt; clazz); //把JSON文本parse成JavaBean集合public static final String toJSONString(Object object); // 将JavaBean序列化为JSON文本public static final String toJSONString(Object object, boolean prettyFormat); // 将JavaBean序列化为带格式的JSON文本public static final Object toJSON(Object javaObject); 将JavaBean转换为JSONObject或者JSONArray。 具体程序如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227package niko;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.TypeReference;import com.alibaba.fastjson.serializer.SimplePropertyPreFilter;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;/** * Created by niko on 2017/1/6. */public class fastjsonTest &#123; static class user&#123; private Long id; private String name; public user()&#123; &#125; public user(Long id,String name)&#123; this.id=id; this.name=name; &#125; public Long getId()&#123;return id;&#125; public void setId(Long id)&#123;this.id=id;&#125; public String getName()&#123;return name;&#125; public void setName(String name)&#123;this.name=name;&#125; @Override public String toString()&#123; return "user [id="+id+", name="+name+"]"; &#125; &#125; static class Group&#123; private Long id; private String name; private List&lt;user&gt; users; public Group()&#123; &#125; public Group(Long id,String name)&#123; this.id=id; this.name=name; &#125; public Long getId()&#123;return id;&#125; public void setId(Long id)&#123;this.id=id;&#125; public String getName()&#123;return name;&#125; public void setName(String name)&#123;this.name=name;&#125; public List&lt;user&gt; getUsers()&#123;return users;&#125; public void setUsers(List&lt;user&gt; users)&#123;this.users=users;&#125; @Override public String toString()&#123; return "Group [id=" + id + ", name=" + name + ", gUsers=" + users + "]"; &#125; &#125; public static void main(String arg[]) throws NullPointerException&#123; method1(); method2(); method3(); method4(); method5(); method6(); method7(); &#125; static void method1()&#123; System.out.println("======JavaBean转化示例开始======="); user guestUser=new user(); guestUser.setId(2L); guestUser.setName("guest"); //这里将javabean转化成json字符串 String jsonString=JSON.toJSONString(guestUser); System.out.println(jsonString); //这里将json字符串转化成javabean对象 guestUser = JSON.parseObject(jsonString,user.class); System.out.println(guestUser.toString()); System.out.println("======JavaBean转化示例结束======="); &#125; static void method2()&#123; System.out.println("======List&lt;JavaBean&gt;转化示例开始======="); List&lt;user&gt; users=new ArrayList&lt;&gt;(); for(int i=1;i&lt;4;i++)&#123; user us=new user(Long.valueOf(i),"user"+i); users.add(us); &#125; //这里将List&lt;javabean&gt;转化成json字符串 String jsonString=JSON.toJSONString(users); System.out.println(jsonString); //这里将json字符串转化成List&lt;javabean&gt;对象 users = JSON.parseArray(jsonString,user.class); for(int i=1;i&lt;4;i++)&#123; System.out.println(users.get(i-1).toString()); &#125; System.out.println("======List&lt;JavaBean&gt;转化示例结束======="); &#125; static void method3()&#123; System.out.println("======List&lt;String&gt;转化示例开始========"); List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add("fastjson1"); list.add("fastjson2"); list.add("fastjson3"); //转换为json字符串 String jsonString = JSON.toJSONString(list); System.out.println("json字符串:"+jsonString); //解析json字符串 List&lt;String&gt; list2 = JSON.parseObject(jsonString,new TypeReference&lt;List&lt;String&gt;&gt;()&#123;&#125;); System.out.println(list2.get(0)+"::"+list2.get(1)+"::"+list2.get(2)); System.out.println("======List&lt;String&gt;转化示例结束========"); &#125; static void method4()&#123; System.out.println("======List&lt;Map&lt;String,Object&gt;&gt;转化示例开始========"); Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;(); map.put("key1", "value1"); map.put("key2", "value2"); Map&lt;String,Object&gt; map2 = new HashMap&lt;String,Object&gt;(); map2.put("key1", 1); map2.put("key2", 2); List&lt;Map&lt;String,Object&gt;&gt; list = new ArrayList&lt;Map&lt;String,Object&gt;&gt;(); list.add(map); list.add(map2); //转化成json字符串 String jsonString = JSON.toJSONString(list); System.out.println("json字符串:"+jsonString); //解析json字符串 List&lt;Map&lt;String,Object&gt;&gt; list2 = JSON.parseObject(jsonString,new TypeReference&lt;List&lt;Map&lt;String,Object&gt;&gt;&gt;()&#123;&#125;); System.out.println("map的key1值"+list2.get(0).get("key1")); System.out.println("map的key2值"+list2.get(0).get("key2")); System.out.println("ma2p的key1值"+list2.get(1).get("key1")); System.out.println("map2的key2值"+list2.get(1).get("key2")); System.out.println("======List&lt;Map&lt;String,Object&gt;&gt;转化示例结束========"); &#125; static void method5()&#123; System.out.println("======其他转化示例开始========"); List&lt;Group&gt; groups=new ArrayList&lt;&gt;(); for(int i=1;i&lt;4;++i)&#123; Group gp=new Group(Long.valueOf(i),"gp"+i); List&lt;user&gt; ue=new ArrayList&lt;&gt;(); for(int j=1;j&lt;3;j++)&#123; user u=new user(Long.valueOf(j),"u"+j); ue.add(u); &#125; gp.setUsers(ue); groups.add(gp); &#125; //转换为json字符串 String jsonString=JSON.toJSONString(groups); System.out.println(jsonString); /** 按照标准json格式输出**/ String jsonString2=JSON.toJSONString(groups,true); System.out.println(jsonString2); /** 如果对某些字段不行序列化，可以使用transient关键字,来标记它为不需要的， * 在fastjson中还提供了一种便捷的方法来自定义我们需要序列化的字段 * SimplePropertyPreFilter filter = new SimplePropertyPreFilter(实体类.class, "字段1","字段2"); * 字段为我们需要序列化的字段，如果实体类中没有改字段则不解析放弃该字段而不会报错。 **/ SimplePropertyPreFilter filter=new SimplePropertyPreFilter(Group.class,"id","users"); String jsonGroup =JSON.toJSONString(groups,filter); System.out.println(jsonGroup); /** json反序列化**/ List&lt;Group&gt; gg =JSON.parseObject(jsonGroup, new TypeReference&lt;List&lt;Group&gt;&gt;()&#123;&#125;); for(int i=0;i&lt;gg.size();i++) &#123; System.out.println(gg.get(i)); &#125; System.out.println("======其他转化示例结束========"); &#125; static void method6()&#123; System.out.println("======有异常的转化示例开始========"); List&lt;user&gt; users=new ArrayList&lt;&gt;(); for(int i=1;i&lt;4;i++)&#123; user us=new user(Long.valueOf(i),"user"+i); users.add(us); &#125; List&lt;Group&gt; groups=new ArrayList&lt;&gt;(); for(int i=1;i&lt;4;++i)&#123; Group gp=new Group(Long.valueOf(i),"gp"+i); gp.setUsers(users);//按照这种方式解析的json格式有问题，具体请运行 groups.add(gp); &#125; String jsonString=JSON.toJSONString(groups); System.out.println(jsonString); System.out.println("======有异常的转化示例结束========"); &#125; static void method7()&#123; System.out.println("======运行报错的示例开始========"); Group group=new Group(); group.setId(1L); group.setName("Admin"); user guestUser=new user(); guestUser.setId(2L); guestUser.setName("guest"); System.out.println(JSON.toJSONString(guestUser)); user rootUser=new user(); rootUser.setId(3L); rootUser.setName("root"); System.out.println(JSON.toJSONString(rootUser)); /** 执行下面的语句会报空指针异常，原因暂时不清楚 **/ group.getUsers().add(guestUser); group.getUsers().add(rootUser); String jsonString= JSON.toJSONString(group); System.out.println(jsonString); System.out.println("======运行报错的示例结束========"); &#125;&#125; 以上程序运行的结果如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586======JavaBean转化示例开始=======&#123;"id":2,"name":"guest"&#125;user [id=2, name=guest]======JavaBean转化示例结束=============List&lt;JavaBean&gt;转化示例开始=======[&#123;"id":1,"name":"user1"&#125;,&#123;"id":2,"name":"user2"&#125;,&#123;"id":3,"name":"user3"&#125;]user [id=1, name=user1]user [id=2, name=user2]user [id=3, name=user3]======List&lt;JavaBean&gt;转化示例结束=============List&lt;String&gt;转化示例开始========json字符串:["fastjson1","fastjson2","fastjson3"]fastjson1::fastjson2::fastjson3======List&lt;String&gt;转化示例结束==============List&lt;Map&lt;String,Object&gt;&gt;转化示例开始========json字符串:[&#123;"key1":"value1","key2":"value2"&#125;,&#123;"key1":1,"key2":2&#125;]map的key1值value1map的key2值value2ma2p的key1值1map2的key2值2======List&lt;Map&lt;String,Object&gt;&gt;转化示例结束==============其他转化示例开始========[&#123;"id":1,"name":"gp1","users":[&#123;"id":1,"name":"u1"&#125;,&#123;"id":2,"name":"u2"&#125;]&#125;,&#123;"id":2,"name":"gp2","users":[&#123;"id":1,"name":"u1"&#125;,&#123;"id":2,"name":"u2"&#125;]&#125;,&#123;"id":3,"name":"gp3","users":[&#123;"id":1,"name":"u1"&#125;,&#123;"id":2,"name":"u2"&#125;]&#125;][ &#123; "id":1, "name":"gp1", "users":[ &#123; "id":1, "name":"u1" &#125;, &#123; "id":2, "name":"u2" &#125; ] &#125;, &#123; "id":2, "name":"gp2", "users":[ &#123; "id":1, "name":"u1" &#125;, &#123; "id":2, "name":"u2" &#125; ] &#125;, &#123; "id":3, "name":"gp3", "users":[ &#123; "id":1, "name":"u1" &#125;, &#123; "id":2, "name":"u2" &#125; ] &#125;][&#123;"id":1,"users":[&#123;"id":1,"name":"u1"&#125;,&#123;"id":2,"name":"u2"&#125;]&#125;,&#123;"id":2,"users":[&#123;"id":1,"name":"u1"&#125;,&#123;"id":2,"name":"u2"&#125;]&#125;,&#123;"id":3,"users":[&#123;"id":1,"name":"u1"&#125;,&#123;"id":2,"name":"u2"&#125;]&#125;]Group [id=1, name=null, gUsers=[user [id=1, name=u1], user [id=2, name=u2]]]Group [id=2, name=null, gUsers=[user [id=1, name=u1], user [id=2, name=u2]]]Group [id=3, name=null, gUsers=[user [id=1, name=u1], user [id=2, name=u2]]]======其他转化示例结束==============有异常的转化示例开始========[&#123;"id":1,"name":"gp1","users":[&#123;"id":1,"name":"user1"&#125;,&#123;"id":2,"name":"user2"&#125;,&#123;"id":3,"name":"user3"&#125;]&#125;,&#123;"id":2,"name":"gp2","users":[&#123;"$ref":"$[0].users[0]"&#125;,&#123;"$ref":"$[0].users[1]"&#125;,&#123;"$ref":"$[0].users[2]"&#125;]&#125;,&#123;"id":3,"name":"gp3","users":[&#123;"$ref":"$[0].users[0]"&#125;,&#123;"$ref":"$[0].users[1]"&#125;,&#123;"$ref":"$[0].users[2]"&#125;]&#125;]======有异常的转化示例结束==============运行报错的示例开始========&#123;"id":2,"name":"guest"&#125;&#123;"id":3,"name":"root"&#125;Exception in thread "main" java.lang.NullPointerException at niko.fastjsonTest.method7(fastjsonTest.java:224) at niko.fastjsonTest.main(fastjsonTest.java:78) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:606) at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147) 本文内容参考了一下内容：fastjson使用实例fastjson生成和解析json数据，序列化和反序列化数据FastJson的基本使用fastjson 使用方法 结束语 第一篇技术博客，希望自己能再接再厉，多学习，多实战接下来准备总结一下jetty，请期待……]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[回望2016，展望2017]]></title>
      <url>%2F2016%2F12%2F29%2F%E5%9B%9E%E6%9C%9B2016%EF%BC%8C%E5%B1%95%E6%9C%9B2017%2F</url>
      <content type="text"><![CDATA[回望转眼间，2016就要结束了！回望着这一年，做了很多一直想做的事情，但是也有一些遗憾。 去旅游了人生第一次旅游，去了小妹读书的地方-西安。许多年前一直说要去老妹在的地方去看看，今年终于做到了。 西安作为13朝古都，历史感很重。有许多史人留下的东西：西安城墙，秦始皇兵马俑，大雁塔，华清池……去看的时候，感觉前人好伟大。 我活着很粗糙，不文艺，去旅游的目的很简单，就是出去看看，去感受别的地方的生活，。 爬了华山从夜里10:40-次日13:00，上下华山，现在想想挺佩服自己的……那种征服它的感觉挺不错我是一个喜欢刺激，喜欢冒险的人，以后有机会还想去爬一下华山。 工作了7月份入职，到现在已经工作半年了，感觉自己这半年成长的不多，但是在工作中碰到了很好的人，其实自己还是挺幸运的。 坐飞机了第一次坐飞机，遇到了波动，但是我没有多大感觉，我觉得那个波动太温柔了，嘻嘻，抖M属性暴露了。天上的风景听不错，很干净……以后计划带老爸老妈做一次飞机……然他们也感受一下 写博客了一直想折腾，终于在年底折腾好了，希望自己能坚持下去，虽然自己是一个三分钟热度的人，还有就是文笔很烂……但是还是要写一写，记录下，不然你会感觉生活没在你身上留下什么印记，除了慢慢退化的身体机能…… 展望2017年我要会写代码，这个是总目标……希望自己能做到，为此，我需要了解下面的内容： jetty：java服务端的servlet容器 多线程编程 NIO，对应的有BIO druid Nginx 慢慢来，多向别人请教。必须要学会成长]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我的博客搭建过程—Hexo+GithubPage]]></title>
      <url>%2F2016%2F12%2F28%2F%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B-Hexo-GitHubPages%2F</url>
      <content type="text"><![CDATA[参考文章 最详尽-hexo+GithubPages搭建博客 hexo官方文档 hexo主题更换为next next官方文档 安装Hexo 安装Hexo前，需要确保电脑中已经安装了node.js和git，如果已经安装，我们就可以使用npm来安装Hexo了 新建文件夹niko,进入此文件夹，点击鼠标右键，选择Git Bush Here，在该文件下，安装Hexo，执行下面的命令 1npm install -g hexo-cli 初始化框架执行下面的命令hexo init blog,该命令会在niko文件夹下生产blog文件夹，执行下面的命令 12cd blognpm install 以上三条语句执行完毕，会在blog文件夹下面看到如下的目录： 123456├── _config.yml //网站的配置信息，您可以在此配置大部分的参数。 ├── package.json ├── scaffolds //模版文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。 ├── source //资源文件夹是存放用户资源的地方。 | ├── _posts └── themes //主题文件夹。Hexo会根据主题来生成静态页面。 最后看看自己的文章 新建一篇文章 1hexo new "my first blog" 执行该命令后会在/source/_post里自动生成了“my first blog.md”文件，之后新建的文章都将存放在此目录下。编辑“my.first blog.md”文件可修改内容。 生成网站 1hexo genereate,可简写成hexo g 启动本地服务器 1hexo server,可简写成hexo s 启动成功后，通过访问http:localhost:4000就可以查看到网站内容。 注意：可能访问上面的网址时，没有反应，这时很有可能是4000端口被占用了，这时通过下面的命令更改端口即可 1hexo s --port=5000 注册GitHub新建repository注册成功后，新建repository，如下所示： repository-name为你GitHub账户的用户名+github.io,比如我的GitHub账户名为niko-w,则新建的repository-name为niko-w.github.io Description里随便填一下你的描述就好 Public选中 选中Initilize this respository with a README 最后点击绿色按钮创建 配置SSH-key配置方法请参考此处 部署blog到GitHubPages上两种部署方式： 使用hexo deploy部署 使用git push部署 博主建议：对于git操作不熟悉的可以直接使用第一种方式部署，简单快速，也不易出错。 hexo deploye部署 配置deploy 找到站点配置文件_config.yml(在blog文件夹下)，用编辑器打开此文件 找到此文件的deploy字段，按照以下配置 1234deploy: type: git repo: git@github.com:niko-w/niko-w.github.io.git branch: master 在此操作之前需要安装一个扩展： 1npm install hexo-deployer-git --save 然后执行下面的命令，即可将本地内容上传到GitHub中 1hexo d git push方法 进入到blob文件夹下的public文件夹下，执行下面命令： 123456git initgit add .git commit -m "message"//引号内的内容科技自己书写git remote add origin git@github.com:niko-w/niko-w.github.io//本地仓库链接到远程仓库git push -u origin master//第一次推送这样写git push origin master//以后每次推送可以这样写 git相关操作可参考廖雪峰git教程 在push的过程中可能会遇到一些问题 push失败 报failed to push some refs to &#39;https://github.com/niko-w/niko-w.github.io&#39;,如下图： 这个问题主要是由于GitHub上ReadMe文件没有同步到本地仓库中，通过执行命令git pull --rebase origin master来解决 git pull –rebase origin master有冲突解决冲突，执行以下命令： 12git add -ugit rebase --continue 最后再执行下面的命令即可 1git push -u origin master 部署成功后，在浏览器中输入你的repository-name就可以访问你的博客了，楼主的是niko-w.github.io 域名购买和解析 在阿里云购买域名进行解析，解析方法请百度 进入blog下的public文件夹，新建CNAME 通过鼠标右键-&gt;新建txt文档，将文件名改为CNAME，注意不要保留后缀.txt 在CNAME中添加你的域名，比如我的niko99.me 将CNAME文件上传到GitHub上 执行命令hexo d 以上操作执行完之后，在浏览器中输入你购买的域名，即可访问你的博客了 以上就是搭建博客的整个流程，写的比较粗糙，很多内容待完善和补充……各位看官就将就着看吧 (^__^)]]></content>
    </entry>

    
  
  
</search>
